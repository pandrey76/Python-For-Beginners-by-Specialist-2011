#!/usr/bin/env python
# -*- coding: utf-8 -*-

C = { u"c" : 10,
      u"b" : 1234,
      u"a" : 9877
     }
#Словарь - это список кортежей.     
#если в словаре окажется повторяющийся ключ то второй элемент 
#затрет первый

#операция взятия по итератору при этом возврашаются ключи     
for K in C :
    print K     #результат a c b
    

#Выдача ключей по порядку
L = C.keys()
L.sort()
for K in L :
    print K     #результат a b c

#Перебор по парам ключ/значение
#########################################
#Способ 1
#iteritems это генератор-функция которая выдаёт последовательно ключ/значение    
for ( K, V ) in C.iteritems() :
    print K, V
    
#Способ 2
#Второй способ хуже так как медленней работает из-зи того что происходит дополнительная операция 
#поиска элемента по ключу. а в случае с iteritems возвращается два значения в виде кортежа
#ключ и значение, но это не критично, так как большие словарей на практике не встречаются
for K in C :
    print K, C[K]
#########################################

#Если запрошеного ключа в словаре нет то сгенерируется исключение типи "KetError"    
#print C[u"d"]  результат исключение типи "KetError"    

#Чтобы этого избежать можно использовать функцию get если ключа нет то будет возвращено значение
#которое идёт вторым параметорм функции get
print C.get( u"d", u"<no data>")    #результат  no data

#Обычно на практике существует два способа
#1 вариант Если элемент есть в списке то сделат с элементом какие-то  действия
#если нет то перехватить исключение и совершить определённые действия
#2 вариант Если элемент есть в списке то сделат с элементом какие-то  действия
#если нет то взять определённое значение по умолчанию (эти 2 варианта востребованы в 90% случаев
