#!/usr/bin env python
# -*- coding: utf-8 -*-

X = u"Вася Пупкин"
print X 
#результат: Вася Пупкин

print [X]
#результат: [u'\u0412\u0430\u0441\u044f \u041f\u0443\u043f\u043a\u0438\u043d']

#Функция print [X] отображает строку в виде списка сиволов ASCII и если она не
#находит представление в ASCII то она отображает юникод представление.

Y = u"\u0412ася Пупкин"

print Y
#результат: Вася Пупкин
print [Y]
#результат: [u'\u0412\u0430\u0441\u044f \u041f\u0443\u043f\u043a\u0438\u043d']

#for K in [Y]
#    print K

########### Работа с файлами ###########
#Функция открытия файла
#Первый параметр: путь к файлу
#Второй параметр: Режим
#wt+ - запись текстового файла с возможностью позиционирования в файле
#at - запись текстового файла с добавлением без возможности позиционирования в файле
#wt+ - запись текстового файла с добавлением с возможностью позиционирования в файле
#rt - чтение из текстового файла

#wb+ - запись бинарного файла с возможностью позиционирования в файле
#ab - запись бинарного файла с добавлением без возможности позиционирования в файле
#wb+ - запись бинарного файла с добавлением с возможностью позиционирования в файле
#rb - чтение из бинарного файла

FD = open ( u"D:\\temp.txt", "rt" );
#FD -дискриптор файла, объект - генератор
for Line in FD :
    print Line
#результат: Файл построчно, в Line находится строка до символа перевола строки
#команда print сама тоже делает перевод строки
#Поэтому вывод получается с двойным перводом строк

FIL = open ( u"D:\\temp.txt", "rt" );
for Line in FIL :
    print Line,
#результат: Файл построчно, в Line находится строка до символа перевода строки
#команда print если поставлена запятая не делает перевод строки
#Поэтому вывод получается как в считанном файле

FL = open ( u"D:\\temp.txt", "rt" );
for Line in FL :
    print Line[:-1]
#результат: Файл построчно, в Line находится строка до символа перевода строки
#но на функцию print мы передаём строку без последнего символа (превод на новую строку ) 
#команда print если поставлена запятая не делает перевод строки
#Поэтому вывод получается как в считанном файле

#Вариант с проверкой последнего символа
#########################################
F = open ( u"D:\\temp.txt", "rt" );
for Line in F :
#Используем условное выражение
    L = Line[:-1] if Line[-1] == u'\n' else Line
    print L

#Второй вариант с проверкой последнего символа
F1 = open ( u"D:\\temp.txt", "rt" );
for Line in F1 :
#Используем условное выражение
    if Line[-1] == u'\n' :
        L = Line[:-1]
    else :
        L = Line
    print L
#Функция считывания строки из файла
#L = F1.readline()
#Функция считывания из файла указанное число байт
#L = F1.read(123)
#результат: Считывается не более 123 байт файла
#при повторном вызове функции read она будет считывать
#с того места где она остановилась после предыдущего вызова.
#########################################
#########################################
#Примечание
#В системе Windows символ конца строки состоит из двух символов u"\r\n"
#    \r - символ возврата корретки
#    \n - символ перехода на новую строку

#В системе Macintosh символ конца строки состоит также
#из двух символов но они следуют в обратном порядке u"\n\r"

#В системе Unix символ конца строки состоит из одного символа u"\n"

#########################################
#Если файл открыт в режиме текста ("rt"), то все символы перевода на новую строку,
#на любой операционной системе (двух символьные в том числе) будут приведены к u"\n"
#Поэтому результат работы функции read для режима "rb" и "rt" будут отличаться, т.к. 
#последовательность u"\n\r" или u"\r\n" функция read посчитает за один байт, т.е. байт u"\n"
#При записи будет соответственно обратное преобразование.
#В двоичном файле ничего подобного происходить не будет.
#########################################

#########################################
#Функция записи в файл
#F1.write("aklshfkashdfhasdhfakh")
#Оди из случаев когда не используется модификатор u""
#результат будет мало предсказуем, т.к. функция write
#попытается эту строку перекодировать, поэтому в файл Юникод 
#строки не пишутся их надо предварительно перекодировать
#Другими словами запись F1.write(u"aklshfka")не корректна,
#т.к. Юникод строка состоит из символов а в файл мы можем записать только байты.
#########################################
TRG = open ( u"D:\\temp1.txt", "wt+" );
TRG.write("aklshfkashdfhasdhfakh")
#Так функция тоже корректно сработает
TRG.write(u"aklshfkashdfhasdhfakh")
try :
    #При таком входном параметре функция write сгенерирует исключение UnicodeEncodeError
    #т.к. ей не удалось преобразовать руские буквы в ASCII. 
    #Это преобразование необходимо делать вручную.
    TRG.write(u"Вася Пупкин")
except UnicodeEncodeError :
    print u"TRG.write(u'Вася Пупкин') - UnicodeEncodeError"

#Закрытие файла
#########################################
#Первый способ
TRG.close ( )
#результат: Или файл будет закрыт или будет выдана ошибка
#В дальнейшем переменную TRG можно использовать для получения 
#различной информации о закрытом файле. При этом не рекомендуется 
#использовать эту переменную для переоткрытия файла.

#Второй способ (лучше)
with open ( u"D:\\temp1.txt", "rt" ) as FD_1 :
    for Line in FD_1 :
        print L
#При данной записи переменная FD_1 превращается в "менаджер контента",
#т.е. блок "with" и есть контент. Делаются действия при входе в контент и делаются 
#действия при выходе из контента. В данном случае при входе в контент перменная FD 
#инициализируется функцией "open" и при выходе закрывает файл.

#Пример:
#Задача есть список файлов, надо открыть все файлы из списка последовательно и если 
#первые 5 байт соответствуют слову u"Hello", то прекратить дальнейшую работу
Files = [ u"D:\\temp1.txt", u"D:\\temp.txt"  ]
for Path in Files :
    SRC = open( Path, "rt" )
    Line = SRC.readline()
    if Line[:4] == "Hello" :
        #при корректной отработке услови мне необходимо будет 
        #явно закрыть файл
        SRC.close()
        break
    SRC.close()
    
#Второй способ
for Path in Files :
    with open( Path, "rt" ) as SRC :
        Line = SRC.readline()
        if Line[:4] == "Hello" :
            break
#Здесь менадхер контента гарантировано закроет файл
#При желании можно писать свои менаджеры контентов.
