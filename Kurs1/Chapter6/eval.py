#!/usr/bin/env python
# -*- coding: utf-8 -*-

#В Python мы можем взять символьную строку и интерпертировать её.
#В Python символьные строки можно создавать тремя способами
#Способ №1 в двойных ковычках
X = u"Вася Пупкин хороший парень"
print X
#Способ №2 в одинарных ковычках
Y = u'Вася Пупкин хороший парень'
print Y
#не важно какие кавычки, главное чтобы они попарно соответствовали
#друг другу
########################################################
#Способ №3 в тройных ковычках
#При этом надо учитывать, что символы перехода на новую строку и пробелы
#вначале строк будут пресутствовать в строке. Поэтому использование данного 
#способа не всегда целесообразно. Удобнее писать строки с обычными ковычками
#и ставить между ними плюсы.
W = u'''
    Вася Пупкин 
    хороший 
    парень
    '''
print W
#Такие строки используются в основном в трёх случаях

#1 случай 
#Это строка интерпретации, т.е. команды распологаются на отдельных строках
# C = u'''
#        Y = X + C
#        print Y
#      '''

#2 случай
#Запрос к базе данных, отдельные элементы распологаются на отдельных строках.
#Как правило при обработке запроса базой данных не учитываются лишние пробелы и 
#символы новой строки.

#3 случай
#Строка документации
########################################################

#Общее правило: Если функция ничего не возвращает, то она возвращает "None"

X = u"3+2"
print eval(X)   #результат 5
#Функция eval принемает строку и возвращает результат выражения находящегося в ней, т.е
#воспринимает строку, как выражение. Эта комманда работает, как  lambda функция и она
#позволяет вычислять, только выражение, но это ограничение можно обойти.

#Общее правило: lambda задаёт функцию
########################################################
#В Python любой объект имеет некое тектовое (графиеское представление.
#Если мы сами создаём объект, то мы можем задать ему собственное текстовое 
#представление, но по соглашению в Python такой способ используется редко.
#Например
X = u"lambda x, y: x + y"
print eval(X)
#результат <function <lambda> at 0x00000000023DDC88>
#function - категория
#<lambda> - Имя
#0x00000000023DDC88 - внутренний дискриптор Python
import math
print math
#результат <module 'math' (built-in)>
#module - категория
#'math' - Имя
########################################################


#Часто используется такое выражение
Y = u"lambda x, y : x + y"
print eval(Y)(3,4)  #результат 7

A = input ( u"A: ") # 2 //23
B = input ( u"B: ") # 3 //A - 13
#O = input ( u": ")  # + - приведет к Syntax Error функции input, т.к. функция input
                    #обрабатывает входные данные как числа и не может корректно интерпретировать +.
                    #как число. Поэтому необходимо вводить u"+".
#Для того, чтобы ввести текст с консоли существует функция raw_input. Данная функция берёт строку и отдаёт в том виде 
#в каком строка была получена.
#Отсюда следует, что функция input, есть eval(raw_input(u": ");
O = u"+";
func = eval(u"lambda x, y : x " + O + u"y")
print func( A, B)   #результат 5    //33
O = raw_input ( u": ")
print func(A, B)   #результат 5     //33

#### Карринг - элемент функционального программирования ####
#Если у нас есть функция которая принимает два параметра, то мы преобразуем 
#эту функцию в другую функцию, которая свои параметры передаёт по одному, т.е. 
#исходная функция преобразуется в последовательность вызовов двух функций с одним 
#входным параметром в каждой.
def func1 ( x, y ) :
    print u"x=", x, u'y=', y #так никто не пишет
#Обычно используют операцию форматирования строки
#операторы формата в целом ка принято в языке С.
#После символьной строки идет картеж с конкретными значениями
    print u"x=%03d y=%d" % ( x, y )
#Ещё есть способ использовать вместо картежа словарь, это используется часто 
#при повторах, ланный приём часто применяется при выводе XML
    print u"x=%(x)d y=%(y)03d x=%(x)d" % {u"x": x, u"y": y }
#Склейка строк команды осуществляется через косую черту как в макросах С
    print u"x=%(x)d y=%(y)d x=%(x)d" \
    % {u"x": x, u"y": y }
func1( 2, 3 )   
 #Как реализуется "карринг"
 #Иногда удобрей вызывать так, когда берётся сначала первый параметр, а потом второй
func2 = lambda x : lambda y : func1(x,y)
func2 ( 2 )( 3 )

def func3 ( x) :
    def f ( y ) :
        return func1 ( x, y )
    return f
    
func3( 2 ) ( 3 )
#т.е функция получает свои параметры последовательно по одному.
#Таким образом  можно организовать отложенные вычисления
